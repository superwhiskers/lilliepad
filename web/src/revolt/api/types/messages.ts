import type { AutumnId, Id, Nonce } from "./common";
import type { File } from "./autumn";
import type { JanuaryEmbed } from "./january";
import { User } from "./users";
import { Member } from "./servers";

/**
 * @description ISO8601 formatted timestamp
 * @example 1970-01-01T00:00:00Z
 */
export type ISO8601Timestamp = string;

/**
 * Masquerade displayed for a message.
 * Replaces user's name and avatar.
 */
export type Masquerade = {
  /**
   * Nickname to display
   */
  name?: string;

  /**
   * Avatar URL
   */
  avatar?: string;
};

/** @description Representation of a Message on Revolt */
export type Message = {
  /** @description Unique Id */
  _id: Id;

  /** @description Unique value generated by client sending this message */
  nonce?: string;

  /** @description Id of the channel this message was sent in */
  channel: Id;

  /** @description Id of the user that sent this message */
  author: Id;

  /** @description Message content */
  content?: string;

  /** @description System message */
  system?: SystemMessage;

  /** @description Array of attachments */
  attachments?: File[];

  /** @description Time at which this message was last edited */
  edited?: ISO8601Timestamp;

  /** @description Attached embeds to this message */
  embeds?: Embed[];

  /** @description Array of user ids mentioned in this message */
  mentions?: Id[];

  /** @description Array of message ids this message is replying to */
  replies?: Id[];

  /** @description Name and / or avatar overrides for this message */
  masquerade?: Masquerade;
};

export type SystemMessage =
  | { type: "text"; content: string }
  | { type: "user_added"; id: Id; by: Id }
  | { type: "user_remove"; id: Id; by: Id }
  | { type: "user_joined"; id: Id }
  | { type: "user_left"; id: Id }
  | { type: "user_kicked"; id: Id }
  | { type: "user_banned"; id: Id }
  | { type: "channel_renamed"; name: string; by: Id }
  | { type: "channel_description_changed"; by: Id }
  | { type: "channel_icon_changed"; by: Id };

export type TextEmbed = {
  type: "Text";

  icon_url?: string;
  url?: string;
  title?: string;
  description?: string;
  media?: File;
  colour?: string;
};

export type Embed = TextEmbed | JanuaryEmbed | { type: "None" };

export type SendableEmbed = {
  type: "Text";

  icon_url?: string;
  url?: string;
  title?: string;
  description?: string;
  media?: string;
  colour?: string;
};

export interface SendMessage {
  /**
   * Message content to send.
   * @minLength 0
   * @maxLength 2000
   */
  content: string;
  /**
   * Attachments to include in message.
   */
  attachments?: AutumnId[];
  /**
   * Embeds to include in the message
   * @minLength 1
   * @maxLength 10
   */
  embeds?: SendableEmbed[];
  /**
   * Messages to reply to.
   */
  replies?: {
    /**
     * Message Id
     */
    id: Id;

    /**
     * Whether this reply should mention the message's author.
     */
    mention: boolean;
  }[];
  masquerade?: Masquerade;
}

export type FetchOptions<IncludeUsers extends boolean> = {
  /**
   * Maximum number of messages to fetch.
   *
   * For fetching nearby messages, this is \`(limit + 1)\`.
   *
   * @minimum 1
   * @maximum 100
   */
  limit?: number;
  /**
   * Message id before which messages should be fetched.
   */
  before?: Id;
  /**
   * Message id after which messages should be fetched.
   */
  after?: Id;
  /**
   * Message sort direction
   */
  sort?: "Latest" | "Oldest";
  /**
   * Message id to fetch around, this will ignore 'before', 'after' and 'sort' options.
   * Limits in each direction will be half of the specified limit.
   * It also fetches the specified message ID.
   */
  nearby?: Id;
  /**
   * Whether to include user (and member, if server channel) objects.
   */
  include_users?: IncludeUsers;
};

export type RetrievedMessages<IncludeUsers extends boolean> = IncludeUsers extends true
  ? { messages: Message[], users: User[], members?: Member[] }
  : Message[]
